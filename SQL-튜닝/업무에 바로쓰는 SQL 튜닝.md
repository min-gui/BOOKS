# sql-tuning

## 업무에 바로 쓰는 SQL 튜닝

<img width="200" alt="image" src="https://contents.kyobobook.co.kr/sih/fit-in/458x0/pdt/9791162244500.jpg">

## 정리
## 목차

* [1. MySQL과 MariaDB개요](#1-mysql과-mariadb개요)
  * [구조적 차이](#구조적-차이)
* [2. SQL 튜닝용어를 직관적으로 이해하기](#2-SQL-튜닝용어를-직관적으로-이해하기)
  * [물리 엔진과 오브젝트 용어](#물리-엔진과-오브젝트-용어)
  * [논리적인 SQL 개념 용어](#논리적인-sql-개념-용어)
  * [개념적인 튜닝 용어](#개념적인-튜닝-용어)
* [3. SQL 튜닝의 실행 계획 파헤치기](#3-SQL-튜닝의-실행-계획-파헤치기)
  * [기본 실행 계획 항목 분석](#기본-실행-계획-항목-분석)
  * [좋고 나쁨을 판단하는 기준](#좋고-나쁨을-판단하는-기준)
  
  
## 1. MySQL과 MariaDB개요


버전 찾기
```sql
SHOW VARIABLES LIKE 'version%';
SELECT @@version;
```


### 구조적 차이
- Oracle
  - 통합된 스토리지 하나를 공유.
  - 사용자가 어느 DB 서버에 접속 하여 작업 하더라도 같은 결과 출력, 동일한 구문 CRUD
  를 처리할 수 있다.
- MySQL
  - 물리적인 DB 서버 마다 독립적으로 스토리지를 할당.
  - 마스터 - 슬레이브 (주-종 구조) 가 대부분. 마스터는 쓰기/읽기 가능, 슬레이브는 읽기만 
  가능. 여러대 DB 서버에 접속해서 CRUD를 실행하더라도 처리되지 않을 수 있다.
  - 상대적인 낮은 메모리 사용.
  - 중첩 루프 조인 알고리즘만으로 풀림.

  
  *_쿼리 오프로딩_  
  트랜잭션 쓰기(UPDATE, INSERT, DELETE) ,읽기(SELECT) 분리하여 처리량 증가 기법
  
  
## 2. SQL 튜닝용어를 직관적으로 이해하기
### 물리 엔진과 오브젝트 용어

- MySQL 엔진
  - Parsor : SQL 문법 검사, SQL 문을 최소 단위로 분리하고 트리 생성.
  - Preprocessor : SQL 문 구조적인 문제 없는지 파악. 테이블, 열, 함수, 뷰와 같은
  오브젝트가 실질적으로 생성된 오브젝트인지 확인. 접근 권한 여부 확인.
  - Optimizer : 핵심 엔진 중 하나. 테이블에 접근 순서계획 설정, 인덱스 사용 여부 및 인덱스 종류 선택 할지와 같은
  실행 계획을 수립.
  - Executor : Optimizer의 실행 계획을 참고하여 스토리지 엔진에서 데이터 가져온다.
  읽어온 데이터를 정렬,조인,필터링 처리한다. 부하를 줄이려면 스토리지에서 가져오는 데이터양을 줄이는게
    중요하다.
- 스토리지 엔진
  - InnoDB : OLTP 지원, 대다수 사용.
  - MyISAM : 풀 텍스트 인덱스, 대량의 쓰기 트랜잭션 발생하면 사용.
  - Memory : 메모리 데이터를 로드하여 빠르게 읽는 효과.

- 실행순서
  - SQL 실행 -> 파서 -> 전처리기-> 옵티마이저 -> 스토리지 엔진 -> 결과 수신
<br><br>
- 인덱스
  - 실제 데이터 위치를 식별하고 데이터 접근 속도를 높이기 위해 키 기준으로 정렬된 오브젝트
- 고유 인덱스(unique index)
- 중복된 값을 허용하지 않는 인덱스, 불필요한 중복 검증 과정이 추가되니 주의.
<br><br>
*___인덱스 주의사항___  
기본키와 똑같은 인덱스를 생성하면 물리적 공간이 낭비되고, 데이터 삽입/삭제/수정에 대한 오버헤드가 발생.  
기본키에는 NULL을 입력할 수 없지만, 고유 인덱스는 입력 가능.
<br><br>
- 뷰
  - 가상테이블, 유령과 같은 오브젝트. 조인 및 개인정보를 외부에 직접적으로 공개하지 않도록 
  제한된 정보만 제공 가능하다. 안전하게 운영 개발 가능해 보안성 향상.


### 논리적인 SQL 개념 용어
- 서브쿼리 위치에 따른 SQL 용어
  - 외부쿼리 outer query
    - SELECT, FROM, WHERE 절로 작성한 메인쿼리
  - 스칼라 서브쿼리
    - 메인뭐리 SELECT 절에 있는 또 다른 SELECT 절.
    - 출력데이터 와 스칼라 서브쿼리의 결과 건수가 일치해야 한다.
    - ```sql
      SELECT 이름, 
            (SELECT COUNT(*))
                FROM 학생 AS 학생2
               WHERE 학생2.이름 = 학생1.이름) 카운트
        FROM 학생 AS 학생1;
      ```
      
  - 인라인뷰
    - FROM 절 내부에서 일시적인 뷰를 생성하는 방식.
    - 메모리 또는 디스크에 임시 테이블을 생성하여 활용.
  - 중첩 서브쿼리
    - WHERE 절에 있는 또 다른 SELECT 절.

- 메인쿼리와의 관계성에 따른 SQL 용어
  - 비상관 서브쿼리
    - 메인쿼리와 서브쿼리 간에 관계성이 없음을 의미
    - 실행 순서 : 서브쿼리 -> 메인쿼리
  - 상관 서브쿼리
    - 메인쿼리와 관계성이 있음, 메인 쿼리에서 값을 받아 서브쿼리의 조건문에 포함되는 경우.
    - 실행 순서 : 메인쿼리 -> 서브쿼리 -> 메인쿼리
- 반환 결과에 따른 SQL 용어
  - 단일행 서브쿼리, (= 조건문)
  - 다중행 서브쿼리, (IN 조건문)
  - 다중열 서브쿼리
    ```sql
    SELECT ...
      FROM ...
     WHERE (이름,전공코드)
           IN 서브쿼리( SELECT 이름, 전공코드 FROM 학생 WHERE 이름 LIKE '김%')
    ```

- 조인 연산방식 용어
  - 내부 조인 (Inner Join) 
  - 왼쪽 외부조인 (Left Outer Join)
  - 오른쪽 외부조인 (RIGHT Outer Join)
  - 교차 조인 (Cross Join)
    - 테이블에서 발생 할 수 있는 모든조합 찾아낸다. 오버헤드 발생 가능
    ``` sql
    SELECT 학생.학번, 학생.이름,
           지도교수.학번, 지도교수.교수명
      FROM 학생
    CROSS JOIN 지도교수
    -- 
    SELECT 학생.학번, 학생.이름,
           지도교수.학번, 지도교수.교수명
      FROM 학생, 지도교수
    ```
  - 자연조인(Natural Join)
    - 동일한 컬럼명이 있을때, 자연조인 실행. Inner Join 과 동일한 결과가 나온다.
    - 동일한 컬럼명이 없을때, 교차조인 과 동일한 결과가 나온다.
    - 일반적으로 잘 사용하지 않는다.

- 조인 알고리즘 용어
  - 조인 테이블은 동시접근이 아니라 순차 접근.
  - 드라이빙 테이블, 드리븐 테이블
    ```sql
    SELECT 학생.학번, 학생.이름,
           비상연락망.관계, 비상연락망.연락처
      FROM 학생 -- 1
      JOIN 비상연락망 -- 3
        ON 학생.학번 = 비상연락망.학번 -- 4  
     WHERE 학생.학번 IN (1, 100) --2
    -- 테이블 접근 우선순위가 존재.
    -- 먼저 점근 테이블인 드라이빙 테이블은 학생 테이블
    -- 학생 테이블 결봐 바탕으로 데이터 검색하는 드리븐 테이블은 비상연락망 테이블.
    ```
  - 중첩 루프 조인(Nested Loop Join) NL 조인
    - 위 쿼리에서 1,100 을 각각 찾는다면,(예 : 비상연락망  1,000건 ) 100+1,000, 100+1,000 대략 2,200건 데이터 접근
    - 학번에 인덱스 설정 가정. 1+2, 1+1 대략 5건 데이터 접근으로 해결 가능.
    - 인덱스는 순차정렬 되지만 찾아가는 광정에서 램덤 엑세스 방식이 발생하여 범위를 좀히는 방법으로 인덱스설계, 조건절을 작성해야 한다.
  - 블록 중첩 루프 조인(Block Nested Loop Join) BNL 조인 
    - 탄생배경 : 학생 테이블(드라이빙 테이블), 비상연락망 테이블 인덱스 X 가정. 학생테이블 1번 접근뒤 비상연락망 전체 접근 해야 한다.
    이때 효율성을 높이고자 탄생.
    - 작동방법 : 드라이빙 테이블 에 결과물들을 조인 버퍼에 적제후 조인 버퍼와 비상연락망 테이블에 순서대로 접근, 풀 스캔 2번할꺼 1번으로 줄일 수 있다. 
    - 'join_buffer_size' 로 제한 가능, dfault 256kb
  - 배치 키 액세스 조인(Batched key access join) BKA 조인
    - 블록 중첩 루프 조인의 조인 버퍼 개념을 그대로 사용한다. 드리븐 테이블에 필요한 데이터 예측, 정렬된 상태로 담는 랜덤 퍼버 개념 도입. 
    다중 범위 일기 Multi Range Read(MRR), 시퀀셜 엑세스를 수행하느 방식
    - 작동방법 : 드라이빙 테이블에서 1,100 데이터가 조인버퍼에 적재. 드리븐 테이블의 인덱스 기발 필요 데이터 램덤 버퍼에 적제후 학번 1,100 데이터를 
      램덤 버퍼 메모리상에 상주. 그리고 학생.학번 = 비상연락망.학번 조인 저건절 비교. 동일 데이터 발견시 반환.
  - 해시 조인 (Hash Join)
    - MySQL 8.0.18 버전부터 지원. MariaDB 5.3 이후 버전부터 중첩 루프 해시 라는 이름으로 제공.
    - 학생, 비상연락망 각각의 학번 1의 해시값을 비교한뒤 동일할 경우만 조인 버퍼에 적재.
    - 아직 MySQL/MariaDB에서 핵심 알고리즘은 아니다.

### 개념적인 튜닝 용어

- 오브젝트 스캔유형
  - 테이블 스캔  
    - 인덱스 거치지 않고 바로 디스크 엑세스
    - 테이블 풀 스캔 : WHERE 절 없이 풀 스캔, 인덱스 없이 사용하는 유일한 방식.
  - 인덱스 스캔 
    - 인덱스 범위 스캔 : 인덱스를 범위 기준으로 스캔한뒤, BETWEEN ~ AND, <,> LIKE 로 인덱스 범위 스캔 수행.
    - 인덱스 풀 스캔 : 인덱스를 처음부터 끝까지 수행, 테이블에 접급하지 않고 인덱스로 구성된 열 정보만 요구. 풀스캔 방식보단 인덱스 풀 스캔 방식이 유리.
    - 인덱스 고유 스캔 : 인덱스 스캔 방식중 가장 효율적, WHERE 절에 기본키 또는 고유 인덱스 선두 열로 설정때 활용
    - 인덱스 루스 스캔 : 인덱스의 필요한 부분들만 골라 스캔, 불필요한 인덱스 키는 무시. GROUP BY, MAX(), MIN() 함수가 포함 되면 작동. 
      이미 오름차순으로 정렬된 인덱스에서 최댓값,최솟값 필요한 경우가 이에 해당.
    - 인덱스 병합 스캔 : 테이블내에 생성된 인덱스들을 통합해서 스캔하는 방식. WHERE 문으로 서로 다른 인덱스를 결함과 교차방식 있으면 모두 실행 계획으로 출력.
      물리적으로 존재하는 개별 인덱스를 각각 수행하므로 접근시간이 몇 배로 걸립니다. 보통 별개로 생성된 인덱스들을 하나의 인덱스로 통합하여 튜닝 또는 하나의 인덱스 만을 수행하도록 변경할 수 있습니다.


- 디스크 접근 방식
  - 데이터 접근시 스토리지의 페이지(데이터 검색 최소 단위)에 접근한다. 페이지 단위로 데이터 읽고 쓰기 가능
  - 시퀀셜 엑세스
    - 인접한 페이지를 차례대로 읽는 순차 접근 방식, 테이블 풀 스캔에서 활용. 인접한 페이지를 여러 개 읽는 다중 페이지 읽기 방식으로 수행.
  - 랜덤 엑세스
    - 임의 접근 방식, 페이지가 위치한 물리적인 위치를 고려하지 않는다.

- 조건 유형
  - WHERE 조건문 기준으로 디스크에 접근. 데이터 검색 하는 조건은 엑세스 조건, 추가로 추출하거나 가공 및 연산하는 조건을 필터 조건.
  - 엑세스 조건
    - WHERE 특정 조건문을 이용해 소량의 데이터 추출하고, 인덱스를 통해 조건절을 선택, 스토리지 엔진의 데이터에 접근하고 MySQL 엔진으로 데이터를 가져온다. 
  - 필터 조건
    - 가져온 데이터 기준 으로 불필요한 데이터를 제거,가공하는 조건
  ```sql
  SELECT * FROM TABLE  
  WHERE ID = 1 -- INDEX 가정. 엑세스 조건
  AND CODE = 'A'; 
  ```

## 응용 용어
### 선택도
- 조건절(WHERE 절 조건문)에 따라 선택되는 데이터 비율을 의미합니다. 해당 열에 중복되는 데이터가 많으면 '선택도가 높다'고 평가.
> 선택도 = 선택한 데이터 건수 ÷ 전체 데이터 건수
- 보통 중복이 제거된 데이터의 건수를 활용하여 선택도를 일반화 한다.
> 변형된 선택도 = 1 ÷ DISTINCT(COUNT 열명)

<br>

- 학번 테이블에 100건의 데이터가 저장되어 있다.
> 학버 열의 선택도 = 1 ÷ 100 = 0.01
 
어떤 학번을 선택하더라도 항상 하느의 유일한 값을 출력하는 0.01의 선택도를 가진다.

```sql

SELECT COUNT(*) -- 전체 데이터 건수 구하기
FORM 학생;
=> 100

SELECT COUNT(DISTINCT 학번) -- 선택도 구하기
FROM 학생;
=> 1
```
이번에는 성별 열에서 '여' 조건에 대한 선택도 예제를 보자.
총 100건의 데이터 중 여성에 해당 되는 데이터는 50건이라고 가정, 0.5의 선택도를 가진다.

### 카디널리티
> 카디널리티 = 전체 데이터 건수 * 선택도
- 중복 되는 값이 적다면 카디널리티가 높다고 평가 할 수 있다.

- 카디널리티 적용 사례
  - 주민등록번호 : 카디널리티 높음
  - 이름 : 카디널리티 중간
  - 성별 : 카디널리티 낮음

### 힌트
- SQL 실행 계획을 변경하거나, 최적화를 위해 사용하는 명령어
- 이름으로 된 학생_IDX01 인덱스가 있다.
```sql
-- 1. 첫번째 방법
SELECT 학번, 전공코드
 FROM 학생 /*! USE INDEX(학생_IDX01) */
WHERE 이름 = '유재석';
-- 2. 두번째 방법
SELECT 학번, 전공코드
FROM 학생 /*! USE INDEX(학생_IDX01) */
WHERE 이름 = '유재석';

```

- 강력하지 않은 힌트
  - 명시적으로 힌트를 작성해도 옵티마이저는 무조건 힌트를 참고하지 않습니다. 옵티마이저가 비효율적이라고 예측하면 사용자가 작성한 힌트는 무시될 수 있습니다.
- 힌트 사용 시 고려사항
  - 힌트를 사용해 인덱스를 사용할 것이라고 작성하고 해당 인덱스를 삭제하면, MySQL과 MariaDB는 에러를 발생시키고, 오라클은 이를 무시하고 실행한다.

### 콜레이션(collation)
- 데이터베이스에서 문자열을 비교하거나 정렬할 때 사용하는 규칙
- utf8_bin, utf8_general_ci A a B b 의 대소관계 비교
  - utf8_bin : A > B > a > b
  - utf8_general_ci : A > a > B > b
- 데이터베이스 단위, 테이블 단위, 열단위 까지 세세하게 설정 가능하다.
- 테이블 전체가 utf8_general_ci로 설정되어 있을 때, 특정 열만 utf8_bin으로 설정가능.
- 캐리터셋(character set) : 데이터 저장을 어떻게 할 것인가?
  - 예) utf8 (다국어), utf8mb4(다국어 + 이모지)
- 콜레이션(collation) : 데이터를 어떻게 비교할 것인가?
  - 예) utf8_general_ci(대소문자 구분 x), utf8_bin(대소문자 구분 o)

  
### 통계정보
- 어떤 테이블을 드라이빙 테이블로 선택할지 등을 결정.
- 통계정보를 통해 옵티마이저가 실행 계획을 수립.

### 히스토그램
- 테이블의 열값이 어떻게 분포되어 있는지를 알려주는 통계정보
- 데이터 분포 파악: 데이터가 특정 구간에 많이 몰려 있는지, 골고루 분포되어 있는지 등을 시각적으로 확인할 수 있다.

```sql
-- 히스토그램 정보 직접 생성하기 MySQL
ANALYZE TABLE 테이블명 UPDATE HISTOGRAM ON 열명 나열;

-- 예시
ANALYZE TABLE 사원 UPDATE HISTOGRAM ON 이름;

-- 확인
SELECT * FROM INFORMATION_SCHEMA.COLUMN_STATISTICS;
를 통해서 결과 확인
```

## 3. SQL 튜닝의 실행 계획 파헤치기
### 실행 계획 수행
- 3가지 실행 계획 수행문이 있습니다. 어떤 수행문을 사용하든지 결과는 똑같습니다.
  - EXPLAIN SQL 문;
  - DESCRIBE SQL 문;
  - DESC SQL 문;
- 실행 계획 수행 (MySQL)
```sql
-- MariaDB에 비해 partitions, filtered열이 추가되면서 더많은 정보를 보여줍니다.
EXPLAIN SELECT * FROM 사원
WHERE 사원번호 BETWEEN 10001 AND 20000;

```
- 실행 계획 수행 (MariaDB)
```sql
-- 10.0.5 이상에서는 UPDATE, DELETE 문에서도 실행 계획을 보여줍니다.
EXPLAIN SELECT * FROM 사원
WHERE 사원번호 BETWEEN 10001 AND 20000;

```

### 기본 실행 계획 항목 분석
- id : SQL 문이 실행 되는 순서를 표시.
- select_type : 서브쿼리 인지, UNION 으로 묶여있는지 알려주는 정보.
  - SIMPLE : UNION이나 내부 쿼리가 없는 SELECT 문 을 의미. 단순한 쿼리.
  - PRIMARY : 서브쿼리를 포함한 SELECT 문이거나, UNION이 포함된 SQL 문에서 첫번째로 작성된 쿼리 문이다.
  - SUBQUERY : 독립적으로 실행 되는 서브쿼리를 의미.
  - DERIVED : FROM 절에 작성된 서브쿼리를 의미.
  - UNION : UNION 및 UNION ALL 구문으로 합쳐진 SELECT 문 첫 번째 SELECT 구문을 제외한 이후이 SELECT 구문을 나타낸다.
  - UNION RESULT : UNION ALL 이 아닌 UNION 구문으로 SELECT 절을 결합했을 때 출력됩니다.
  - DEPENDENT SUBQUERY : UNION, UNION ALL을 사용하는 서브쿼리가 메인 테이블의 영향을 받는 경우로, UNION 으로 연결된 단위 쿼리들 중에서 처음으로 작성한 단위 쿼리에 해당되는 경우 입니다.
  - DEPENDENT UNION : DEPENDENT SUBQUERY 와 조건은 동일하고, 두번째 단위 쿼리를 말한다.
  - UNCHCHEABLE SUBQUERY : 메모리에 상주하여 재활용되어야 할 서브쿼리가 재사용되지 못할 때 출력되는 유형입니다.
  - MATERIALIZED : IN 절 구문에 연결된 서브쿼리가 임시 테이블을 생성한 뒤, 조인이나 가공 작업을 수행할 때 출력되는 유형입니다.
- table : 말 그대로 테이블, 테이블명을 표시하는 항목입니다.
- partition : 데이터가 저장된 논리적인 영역을 표시하는 항목입니다. 사전의 정의한 전체 파티션중 특정 파티션에 선택적으로 접근하는것이 성능측면에서 유리합니다.
  많은 파티션에 접근한다면 파티션 정의를 튜닝해야합니다.
- type : 테이블의 데이터를 어떻게 찾을지에 대한 정보를 제공합니다. 인덱스를 통해 탐색할지에 대한 정보를 해석할 수 있습니다.
- key_len : 인덱스 전체를 사용하거나 일부를 사용합니다. 사용한 인덱스 바이트 수를 나타냅니다.
- ref : 어떤조건으 해당테이블에 엑세스 되었는지를 알려주는 정보 입니다.
- rows : 접근하는 데이터의 모든행수를 나타내는 예측 항목입니다. SQL 문의 최종 결과 건수와 비교해 차이가 클경우 튜닝의 대상이 될 수 있습니다.
- filtered : DB 엔진에서 가져온 데이터 대상으로 필터 조건에 따라 어느정도 비율로 데이터를 제거했는지를 의미하는 항목입니다.
- extra : SQL문을 어떻게 수행할 것인지에 관한 추가정보를 보여주는 항목입니다.

### 좋고 나쁨을 판단하는 기준
- select type 항목
  
  | 좋음      | 나쁨          |
  |---------|-------------|
  | SIMPLE  | DEPENDENT   |
  | PRIMARY | UNCACHEABLE |
  | DERIVED |             |

- type 항목

  | 좋음     | 나쁨           |
  |--------|--------------|
  | system | index        |
  | const  | all          | 
  | eq_ref |              |

- extra 항목

  | 좋음          | 나쁨              |
  |-------------|-----------------|
  | Using index | using filesort  |
  |             | using temporary |