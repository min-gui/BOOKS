

```table-of-contents
```

이장에서는 G1 가비지 컬렉터 를 다루고, 잘 알려져 있지 않은 컬렉터를 소개합니다.
- 셰넌도어
- Z 가비지 컬렉터(ZGC)
- Balanced
- 레거시 핫스팟 컬렉터
이 모든 컬렉터가 핫스팟 가상 머신에 사용되지는 않습니다.


### 5.1 트레이드오프와 플러그형 컬렉터
---
가비지 컬렉터 선택시 주요 사항
- STW (일시중지,지속시간)
- 처리량(애플리케이션 실행 시간에 대비 가비지 컬렉터 실행 시간의 비율로 측정됨)
- 일시 중지 빈도(컬렉터가 애플리케이션을 중지해야 하는 빈도)
- 회수 효율성 (단일 가비지 컬렉터가 수집할 수 잇는 가비지의 양)
- 일시 중지의 일관성(모든 일시 중지가 대부분 일정한 길이인지 여부)

배치 작업에서는 일시중지 시간을 줄이는 것보다 CPU 의 효율성을 최적화 하는 가비지 컬렉터 알고리즘이 더 적합할 수 있습니다.l

애플리케이션은 메모리 할당하고 읽는 데 많은 시간을 소비하므로, 가비지 컬렉터에 좀 더 시간을 소모하더라도 메모리 접근 속도를 높이는 것이 바람직합니다.


### 5.2 동시 가비지 컬렉션 이론
---
가비지 컬렉션은 힙에 있는 실제 사용 중인 객체의 그래프만을 추척할 뿐이며,
가비지 컬렉션은 STW의 지속시간과 빈도가 비결정적 이라는것이 주요 불편 사항이다.

해결책으로는 동시로 작동하는 컬렉터를 사용하는 것 입니다.

동시 컬렉터를 논의 하기전에, 현대 가비지 컬렉터의 핵심 개념과 동작 방식을 이해하는 데 필수적인 자바 가바지 컬렉션 용어와 기술을 먼저 정리할 필요가 있습니다.


#### 5.2.1 자바 가상 머신 세이프포인트
---
STW 가비지 컬렉션을 수행하려면, 핫스팟의 병렬 컬렉터가 하는 것처럼 모든 애플리케이션 스레드를 중지해야합니다. 

`자바 가상 머신은 실제로 완전히 선점형 멀테 스레딩 환경이 아닙니다.`

cc. 자바 스레딩은 기본적으로 OS 스케쥴링 정책에 의존한다. 기본 네이티브 스레드와 1:1매핑 하는 모델을 채택하고 있습니다. 자바 스레드 실행 중지는 운영체제 스케줄링 의해 결정. 운영체제는 선점형 스케줄링을 사용함으로, JVM 역시 사실상 선점형이다.  특정 내부 작업은 JVM이 직접 제어권을 가져옵니다. 가비지 컬렉터는 Stop-the-World라는 이벤트를 발생시킵니다. 이 순간, 모든 애플리케이션 스레드가 강제로 중단되고, GC 작업이 완료될 때까지 어떤 스레드도 실행될 수 없습니다. 이는 운영체제의 스케줄링과 무관하게 JVM 자체의 제어에 의해 발생하는 현상으로, 순수한 선점형 모델과는 다른 **협력적(Cooperative) 스케줄링**의 요소가 반영된 것입니다.

자바 가상머신은 조정된 작업을 수행해야 합니다. 이를 가능하게 하기 위해 런타임 각 애플리케이션 스레드가 세이프포인트 라고 부리는 특정 실행 지점을 가지도록 요구합니다. 이지점에서 스레드의 내부 데이터 구조는 안정된 상태를 유지하며, 스레드는 조정된 작업을 위해 중단될 수 있습니다.

컬렉터가 실행되려면 안정적인 객체 그래프가 필요합니다. 이를 위해 모든 애플리케이션 스레드가 일시 중지되어야 합니다.

가비지 컬렉터가 운영체제를 통해 스레드를 강제 중지 시킬 방법은 없다. 따라서 가상 머신 내부에서 실행되는 애플리케이션 스레드가 협력하여 달성해야 합니다.

자바 가상 머신의 세이프포인트 접근 2가지 원칙
- 스레드를 강제로 세이프포인트 상태로 전환할 수 없습니다.
- 스레드가 세이프포인트 상태를 벗어나는 것을 막을 수 있습니다.

자바 가상 머신 인터프리터 구현에서는 세이프포인트가 필요한 경우를 감지하고 양보하도록 하는 코드가 포함되어야 합니다. JIT 컴파일된 메서드에서 생성된 기계어 코드에 해당 장병이 삽입되어야 합니다.
세이프포인트에 도달하는 일반적인 과정
- 전역적으로 '세이프포인트으로 진입할 시간' 플래그를 설정합니다.
- 개별 애플리케이션 스레드가 이 플래그를 감지하고 설정된 상태인지 확인합니다.
- 스레드가 중단된 후 다시 깨울 때까지 대기합니다.
일반 애플리케이션 스레드는 폴링 매커니즘을 사용합니다.
인터프리터 모드에서는 두 바이트코드 실행 사이마다 이 플래그를 확인합니다. JIT 컴파일된 코드에서 주로 컴파일된 메서드를 종료할 때와 루프가 뒤로 분기할 때 폴링 지점이 삽입됩니다.

'모든 스레드가 멈춰야 STW 단계가 시작될 수 있다는 개념은 java.util.concurrent  라이브러리의 CountDownLatch가 구현하는 래치와 유사합니다.'

특정 세이프포인트 조건은 다음과 같이 요약 할 수 있습니다.
- 스레드가 자동으로 세이프포인트에 진입하는 경우
	- 모니터에서 차단된 경우
	- 자바 네이티브 인터페이스(JNI) 코드를 실행 중인 경우
- 스레드가 반드시 세이프포인트에 있는 것은 아닌경우
	- 바이트코드를 실행 중인 경우(인터프리터 모드)
	- 운영체제가 스레드를 인터럽트한 경우
	- JIT 컴파일된 코드에서 명시적인 세이프포인트에 있지 않은 경우

#### 5.2.2 삼색 마킹
---
가비지 컬렉션 이론에서 중요한 역할.
회색 노드 집합 : 발견되었지만 아직 완전히 처리되지 않은 노드.
동작방식
- GC 루트는 회색으로 표시됩니다.
- 다른 노드(객체)는 흰색으로 표시됩니다.
- 마킹 스레드는 무작위로 회색 노드를 선택합니다.
- 선택된 노드에 희색 자식 노드가 없으면, 해당 노드는 검은색으로 변경됩니다.
- 반대로 흰색 자식 노드가 있다면, 마킹 스레드는 해당 자식 노드를 회색으로 변경한 후 탐색을 계속합니다.
- 이 과정을 회색 노드가 남지 않을 때까지 반복합니다.
- 검은색 객체는 도달 가능한 것으로 판명되므로 수집하지 않습니다.
- 반면, 흰색 노드는 도달할 수 없는 객체로 간주되어 가비지 컬렉션의 대상이 됩니다.

동시 컬렉션에서는 즉시 스냅샷(SATB) 이라는 기법을 자주 사용합니다.
- 컬렉션이 시작될 때 도달 가능한 객체나 컬렉션 도중 새로 생성된 객체를 살아있는 객체로 간주 하는 방식
- 예를 들어 컬렉션이 실행 중일때 새로운 객체는 검은색 상태로, 컬렉션이 진행중이 않을 때는 흰색 상태로 표시.

마킹 스레드가 이미 객체를 검은색으로 표시한 후, 애플리케이션(변경자) 스레드가 해당 객체를 흰색 객체로 업데이트했다고 가정해 보겠습니다. 

만약 회색 개체에서 새 흰색 개체에 대한 모든 참조가 삭제된 경우, 해당 흰색 객체에 여전히 도달해야 하지만, 알고리즘 규칙에 따라 찾을 수 없으므로 삭제 됩니다.

이 문제는 여러 가지 방법으로 해결할 수 있습니다. 예를 들어 , 검은색 객체를 다시 회색으로 바꾸고 업데이트 과정에서 다시 처리해야 할 노드 집합에 추가하는 방법이 있습니다. 이러한 접근 방식은 업데이트 쓰기 장벽을 사용하는 방법으로 알고리즘 속성이 마킹 사이클 전체에서 삼색 불변성을 유지할 수 있는 장점을 가지고 있습니다.

G1은 리마크 단계로 알려진 기법을 사용합니다.

#### 5.2.3 포워드 포딩
---
기존의 GC는 'Stop-the-World' 이벤트를 통해 모든 애플리케이션 스레드를 멈추고 메모리 정리를 수행했습니다. 이 동안 사용자 애플리케이션은 응답하지 않아 지연이 발생합니다.

반면, 동시성 GC(예: G1 GC의 일부 단계, ZGC, Shenandoah GC)는 GC 스레드가 메모리 컴팩션 작업을 수행하는 동안에도 애플리케이션 스레드가 계속 실행되도록 설계되었습니다. 이 때 **'브룩스 포인터(Brooks Pointer)'**와 같은 포워딩 포인터 기술이 사용됩니다.

- GC 가 새로운 메모리 공간에 객체를 복사한다.
- 원래 객체의 브룩스 포인터가 복사된 객체의 새로운 주소를 가리키도록 업데이트 한다.
- 애플리케이션 스레드가 기존 객체의 접근하려면 브룩스 포인트를 통해 자동으로 새 주소로 리다이렉션 됩니다.
이러한 방식 덕에 애플리케이션은 GC 작업으로 인해 멈추지 않고 계속 실행될 수 있으며, 지연 시간을 최소화할 수 있습니다.

### 5.3 G1
---
병렬 컬렉터와 매우 다른 방식이며, 자바 6에서 불안정한 형태로 동입, 자바 7 에서 광범위 하게 다시 작성 되었습니다. 자바 8u40 에서 안정적이고 프로덕션 환경에서 사용할 수 있는 상태가 되었습니다.

cc. 자바 9버전 부터 기본 GC 적용.

특징
- 동시 마크 스윕보다 튜닝이 훨씬 쉬움
- 객체 조기 승격에 덜 취약함
- 큰 힙에서 더 나은 확장성(특히 일시 정지 시간)을 가짐
- 전체 STW 컬렉션으로 돌아갈 필요성을 크게 줄임


G1 에서 가장 중요한 개념은 일시정지 목표입니다.
일시정지 복표의 기본값은 200ms. 개발자는 최대 시간을 설정 할 수 있습니다.
너무 낮게 설정 되면, 가비지 컬렉션 서브시스템은 목표를 달성할 수 없을 것 입니다.

대부분 기본값보다 훨씬 짧은 경우가 많아 기본값으로 충분합니다.
힙크기가 수십, 수백 GB의 힙 크기의 경우 일시 정지 목표를 조정 해야 합니다.

또 다른점은 세대 구성을 다시 했습니다. G1 은 각세대마다 연속된 전용 메모리 공간을 갖고 있지 않고, 대신 영역을 도입합니다.

#### 5.3.1 G1 힙 레이아웃과 영역

G1 힙은 고정 크기 영역 개념 이며 영역이 모여 세대를 구성 합니다. 기본 적으로 영역들은 1MB 크기이지만, 더큰 힙에서는 그 크기가 더 커질 수 있습니다.

G1 힙은 여전히 메모리에서 연속적이지만, 각 세대를 구성하는 메모리가 더 이상 연속적일 필요는 없습니다.
여전히 young generation(eden, survivor) 으로 구성 되어 있습니다. 

자바 21부터 G1 알고리즘은 2의 제곱 MB 크기의 영역을 허용합니다. 예를들어 1, 2, 3 ..MB 크기이며 최대 크기는 512MB 입니다. 기본적으로 G1은 힙에서 2,048에서 4,095개의 영역을 기대하며, 이를 달성하기 위해 영역 크기를 조정합니다.

기본적으로 G1힙에서 2,048 ~ 4,095개의 영역을 기대하며 , 달성하기 위해 영역크기를 조정합니다.

영역 크기를 조정하기 위해 다음 값을 사용합니다.
`<Heap size> / 2048`

계산된 값을 가장 가까운 허용 영역 크기 값으로 내림처리합니다. 그런 다음 영역의 수를 다음과 같이 계산합니다.
 `number of regions = <heap size> / <region size>`

애플리케이션에서 영역 크기의 전발 보다 큰 객체를 생성하는 경우, 이를 거대한 객체(humongous object)로 간주합니다.

이러한 객체들은 거대한 (humongous region) 에 직접 할당됩니다.  즉시 Young Generation 이 아닌 영구세대(Permanent Generation) 일부가 됩니다. 일반적인 예는 거대 배열 입니다.

#### 5.3.2 G1 컬렉션
---
2가지 유형이 있다.
- 젊은 세대 가비지 컬렉션
	- 가능할 힙을 빨리 회수 할 려는 STW 컬렉션 입니다. 워밍업 중에, 컬렉터는 가비지 컬렉션 실행 당 얼마나 많은 '일반적인' 영역을 수집할 수 있는지를 추적 합니다. 
- 혼합 컬렉션
	- 대부분 동시로 수행 되며, 젊은 세대 가비지 컬렉션으로 충분하지 않을때 실행 된다. 혼합 컬렉션이 시작 되는 시점을 초기 힘 점유율(initiating heap occupancy percent) 임계값이라고 하빈다.

정리
- 영역 기반이며, 세대별 컬렉터입니다.
- 객체를 이동시키는 방식의 가비지 컬렉터 입니다.
- 통계적 압축(statistical compaction)을 제공합니다.
- 혼합 컬렉션을 위해 동시 마킹 단계(concurrent marking phase) 사용합니다.

#### 5.3.3 혼합 컬렉션
---
대부분 애플리케이션 스레드와 동시에 실행됩니다. 기본적으로 사용가능한 코어 중 일부(최소 하나)는 G1의 동시 단계를 수행하고, 나머지 코어는 애플리케이션 코드를 계속해서 실행 합니다.

실행시 주요 두가지 결과가 발생합니다.
1. 혼합 컬렉션이 실행되는 동안 애플리케이션 처리량이 감소합니다.
2. 동시 컬렉션이 진행 중일 때 젊은 세대 가비지 컬렉션을 수행해야 할 수 있습니다.

혼합컬렉션 도중 젊은 세대 가비지 컬렉션이 실행되어야 하는 경우, 일반적으로 완료 시간이 더 길어집니다.

G1 Old에는 네 가지 단계가 있습니다.
1. 동시시작(STW G1 NEW 포함) : 안정적인 시작 지점 제공
2. 동시 마킹 : 초기 마킹이 완료된후 동시마킹 단계가 시작 됩니다. 
3. 재마킹(STW) : 동시 마킹 이후 G1 Old는 살아있는 객체를 수집하지 않는다를 위반하지 않도록 기록을 수정해야 합니다.
4. 클린업(STW) : 대부분 STW로 이루어져 있으며, 완전히 비워져 재사용할 준비가 된 영역(예 : eden)을 식별하는 회계 작업을 포함합니다.

동시 마킹 단계는 일반적으로 다른 단계들보다 훨씬 오래 걸립니다.
하지만 동시시작,재마킹,클린업 때에는 모든 애플리케이션 스레드가 중지되어야 합니다. ParallelOld와 비교했을때) 긴 STW 일시 정지 하나를 세번의 STW 일시 정지로 대체하는 것입니다. 이들 일시 정지는 보통 매우 짧습니다.

#### 5.3.4 기억집합
---

remembered set 은 영역별로 존재하며, 힙영역으로 포인팅하는 외부 참조를 추적합니다.
포인팅 하는 참조를 찾기위해 전체 힙을 추적하는 대신 기억집합만 검사하고 , 스캔 하면 됩니다.

부유 객체 에 위험성이 있습니다. 전역 마킹에서는 죽은 객체로 간주되지만, 로컬 마킹에서는 사용된 루트 집팝에 따라 잘못 살아있는 것으로 보고될 수 있습니다.

혼합 컬렉션의 클린업 단계 동안 G1 은 기억 집합 세척 작업을 진행 합니다.

#### 5.3.5 전체 컬렉션 (Full GC)
---
힙 전체 (Young , Permanent) 공간을 정리 합니다.

거대한 영역의 단편화 일때 발생, 충분한 여유 메모리가 있더라도 연속된 블록으로 공간이 확보되지 않아 거대한 객체의 할당이 실패할 수 있습니다.

또 다른 가능성은, 사용가능한 힙 메모리를 모두 할당하기 전에 완료되지 못하는 경우입니다.
이 경우 G1은 전체 컬렉션을 수행할 수밖에 없으며, 이를 동시 모드 실패 라고 부르기도 합니다.


#### 5.3.6 G1을 위한 자바 가상 머신 설정 플래그
---
자바 8에서 G1 사용하기 위해 다음 스위치 필요. 
`-XX : UseG1GC`

코어 하나 일때는 직렬 컬렉터롤 대채 됩니다.
G1은 일시정지 목표를 기반으로 합니다. 
`-XX : MaxGCPauseMillis=200`

기본 일시 정지 시간 목표는 200ms 실제로 힙 크기가 한 자리수 GB 정도 라면, 컬렉터가 이 값에 근접하지 않을 가능성이 크며 , STW 시간은 훨씬 짧을 것입니다.

동시 모드 실패하여 전체 가비지 컬렉션이 너무 자주 발생한다면, 초기 힙 점유율 비율 임계값을 조정할 수 있습니다. 이는 초기 힙 점유율 비율 계산에 사용되는 버버 크기를 늘림으로써 수행할 수 있습니다.
`-XX : G1ReservePercent=10`

적응적 접근이 효과가 없을 때만 시도 해야 합니다.
이를 위해 다음 두가지 스위치를 사용할 수 있습니다.
`-XX : -G1UseAdaptiveIHOP`
`-XX : InitiatingHeapOccupancyPercent=45`
초기 힙 점유율 비율의 초기 값만 변경 하고 싶을때 사용.

또다른 옵션으로는 기본 알고리즘을 무시하고 영역 크기를 변경하는 방법이 있습니다.

`-XX :G1HeapRegionSize=<n>m`
<n> 은 1 에서 512 사이의 2의 거드제곱이어야 하며, 단위는 MB 입니다.