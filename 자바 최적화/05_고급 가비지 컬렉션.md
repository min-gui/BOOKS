
이장에서는 G1 가비지 컬렉터 를 다루고, 잘 알려져 있지 않은 컬렉터를 소개합니다.
- 셰넌도어
- Z 가비지 컬렉터(ZGC)
- Balanced
- 레거시 핫스팟 컬렉터
이 모든 컬렉터가 핫스팟 가상 머신에 사용되지는 않습니다.


### 5.1 트레이드오프와 플러그형 컬렉터
---
가비지 컬렉터 선택시 주요 사항
- STW (일시중지,지속시간)
- 처리량(애플리케이션 실행 시간에 대비 가비지 컬렉터 실행 시간의 비율로 측정됨)
- 일시 중지 빈도(컬렉터가 애플리케이션을 중지해야 하는 빈도)
- 회수 효율성 (단일 가비지 컬렉터가 수집할 수 잇는 가비지의 양)
- 일시 중지의 일관성(모든 일시 중지가 대부분 일정한 길이인지 여부)

배치 작업에서는 일시중지 시간을 줄이는 것보다 CPU 의 효율성을 최적화 하는 가비지 컬렉터 알고리즘이 더 적합할 수 있습니다.l

애플리케이션은 메모리 할당하고 읽는 데 많은 시간을 소비하므로, 가비지 컬렉터에 좀 더 시간을 소모하더라도 메모리 접근 속도를 높이는 것이 바람직합니다.


### 5.2 동시 가비지 컬렉션 이론
---
가비지 컬렉션은 힙에 있는 실제 사용 중인 객체의 그래프만을 추척할 뿐이며,
가비지 컬렉션은 STW의 지속시간과 빈도가 비결정적 이라는것이 주요 불편 사항이다.

해결책으로는 동시로 작동하는 컬렉터를 사용하는 것 입니다.

동시 컬렉터를 논의 하기전에, 현대 가비지 컬렉터의 핵심 개념과 동작 방식을 이해하는 데 필수적인 자바 가바지 컬렉션 용어와 기술을 먼저 정리할 필요가 있습니다.


#### 5.2.1 자바 가상 머신 세이프포인트
---
STW 가비지 컬렉션을 수행하려면, 핫스팟의 병렬 컬렉터가 하는 것처럼 모든 애플리케이션 스레드를 중지해야합니다. 

`자바 가상 머신은 실제로 완전히 선점형 멀테 스레딩 환경이 아닙니다.`

cc. 자바 스레딩은 기본적으로 OS 스케쥴링 정책에 의존한다. 기본 네이티브 스레드와 1:1매핑 하는 모델을 채택하고 있습니다. 자바 스레드 실행 중지는 운영체제 스케줄링 의해 결정. 운영체제는 선점형 스케줄링을 사용함으로, JVM 역시 사실상 선점형이다.  특정 내부 작업은 JVM이 직접 제어권을 가져옵니다. 가비지 컬렉터는 Stop-the-World라는 이벤트를 발생시킵니다. 이 순간, 모든 애플리케이션 스레드가 강제로 중단되고, GC 작업이 완료될 때까지 어떤 스레드도 실행될 수 없습니다. 이는 운영체제의 스케줄링과 무관하게 JVM 자체의 제어에 의해 발생하는 현상으로, 순수한 선점형 모델과는 다른 **협력적(Cooperative) 스케줄링**의 요소가 반영된 것입니다.

자바 가상머신은 조정된 작업을 수행해야 합니다. 이를 가능하게 하기 위해 런타임 각 애플리케이션 스레드가 세이프포인트 라고 부리는 특정 실행 지점을 가지도록 요구합니다. 이지점에서 스레드의 내부 데이터 구조는 안정된 상태를 유지하며, 스레드는 조정된 작업을 위해 중단될 수 있습니다.

컬렉터가 실행되려면 안정적인 객체 그래프가 필요합니다. 이를 위해 모든 애플리케이션 스레드가 일시 중지되어야 합니다.

가비지 컬렉터가 운영체제를 통해 스레드를 강제 중지 시킬 방법은 없다. 따라서 가상 머신 내부에서 실행되는 애플리케이션 스레드가 협력하여 달성해야 합니다.

자바 가상 머신의 세이프포인트 접근 2가지 원칙
- 스레드를 강제로 세이프포인트 상태로 전환할 수 없습니다.
- 스레드가 세이프포인트 상태를 벗어나는 것을 막을 수 있습니다.

자바 가상 머신 인터프리터 구현에서는 세이프포인트가 필요한 경우를 감지하고 양보하도록 하는 코드가 포함되어야 합니다. JIT 컴파일된 메서드에서 생성된 기계어 코드에 해당 장병이 삽입되어야 합니다.
세이프포인트에 도달하는 일반적인 과정
- 전역적으로 '세이프포인트으로 진입할 시간' 플래그를 설정합니다.
- 개별 애플리케이션 스레드가 이 플래그를 감지하고 설정된 상태인지 확인합니다.
- 스레드가 중단된 후 다시 깨울 때까지 대기합니다.
일반 애플리케이션 스레드는 폴링 매커니즘을 사용합니다.
인터프리터 모드에서는 두 바이트코드 실행 사이마다 이 플래그를 확인합니다. JIT 컴파일된 코드에서 주로 컴파일된 메서드를 종료할 때와 루프가 뒤로 분기할 때 폴링 지점이 삽입됩니다.

'모든 스레드가 멈춰야 STW 단계가 시작될 수 있다는 개념은 java.util.concurrent  라이브러리의 CountDownLatch가 구현하는 래치와 유사합니다.'

특정 세이프포인트 조건은 다음과 같이 요약 할 수 있습니다.
- 스레드가 자동으로 세이프포인트에 진입하는 경우
	- 모니터에서 차단된 경우
	- 자바 네이티브 인터페이스(JNI) 코드를 실행 중인 경우
- 스레드가 반드시 세이프포인트에 있는 것은 아닌경우
	- 바이트코드를 실행 중인 경우(인터프리터 모드)
	- 운영체제가 스레드를 인터럽트한 경우
	- JIT 컴파일된 코드에서 명시적인 세이프포인트에 있지 않은 경우

#### 5.2.2 삼색 마킹
---
가비지 컬렉션 이론에서 중요한 역할.
회색 노드 집합 : 발견되었지만 아직 완전히 처리되지 않은 노드.
동작방식
- GC 루트는 회색으로 표시됩니다.
- 다른 노드(객체)는 흰색으로 표시됩니다.
- 마킹 스레드는 무작위로 회색 노드를 선택합니다.
- 선택된 노드에 희색 자식 노드가 없으면, 해당 노드는 검은색으로 변경됩니다.
- 반대로 흰색 자식 노드가 있다면, 마킹 스레드는 해당 자식 노드를 회색으로 변경한 후 탐색을 계속합니다.
- 이 과정을 회색 노드가 남지 않을 때까지 반복합니다.
- 검은색 객체는 도달 가능한 것으로 판명되므로 수집하지 않습니다.
- 반면, 흰색 노드는 도달할 수 없는 객체로 간주되어 가비지 컬렉션의 대상이 됩니다.

동시 컬렉션에서는 즉시 스냅샷(SATB) 이라는 기법을 자주 사용합니다.
- 컬렉션이 시작될 때 도달 가능한 객체나 컬렉션 도중 새로 생성된 객체를 살아있는 객체로 간주 하는 방식
- 예를 들어 컬렉션이 실행 중일때 새로운 객체는 검은색 상태로, 컬렉션이 진행중이 않을 때는 흰색 상태로 표시.

마킹 스레드가 이미 객체를 검은색으로 표시한 후, 애플리케이션(변경자) 스레드가 해당 객체를 흰색 객체로 업데이트했다고 가정해 보겠습니다. 

만약 회색 개체에서 새 흰색 개체에 대한 모든 참조가 삭제된 경우, 해당 흰색 객체에 여전히 도달해야 하지만, 알고리즘 규칙에 따라 찾을 수 없으므로 삭제 됩니다.

이 문제는 여러 가지 방법으로 해결할 수 있습니다. 예를 들어 , 검은색 객체를 다시 회색으로 바꾸고 업데이트 과정에서 다시 처리해야 할 노드 집합에 추가하는 방법이 있습니다. 이러한 접근 방식은 업데이트 쓰기 장벽을 사용하는 방법으로 알고리즘 속성이 마킹 사이클 전체에서 삼색 불변성을 유지할 수 있는 장점을 가지고 있습니다.

G1은 리마크 단계로 알려진 기법을 사용합니다.

#### 5.2.3 포워드 포딩
---
기존의 GC는 'Stop-the-World' 이벤트를 통해 모든 애플리케이션 스레드를 멈추고 메모리 정리를 수행했습니다. 이 동안 사용자 애플리케이션은 응답하지 않아 지연이 발생합니다.

반면, 동시성 GC(예: G1 GC의 일부 단계, ZGC, Shenandoah GC)는 GC 스레드가 메모리 컴팩션 작업을 수행하는 동안에도 애플리케이션 스레드가 계속 실행되도록 설계되었습니다. 이 때 **'브룩스 포인터(Brooks Pointer)'**와 같은 포워딩 포인터 기술이 사용됩니다.

- GC 가 새로운 메모리 공간에 객체를 복사한다.
- 원래 객체의 브룩스 포인터가 복사된 객체의 새로운 주소를 가리키도록 업데이트 한다.
- 애플리케이션 스레드가 기존 객체의 접근하려면 브룩스 포인트를 통해 자동으로 새 주소로 리다이렉션 됩니다.
이러한 방식 덕에 애플리케이션은 GC 작업으로 인해 멈추지 않고 계속 실행될 수 있으며, 지연 시간을 최소화할 수 있습니다.