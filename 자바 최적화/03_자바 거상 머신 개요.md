


```table-of-contents
```



전세계 1,000 만 명 이상의 개발자가 사용하는걸로 추정.
고수준의 설계를 바당으로 개발자의 부담을 줄이는 것을 목표.
6장 읽은후 다시 돌와서 읽기.


### 3.1 인터프리팅과 클래스 로딩
---

- 자바 가상 머신 : 스택 기반 인터프리터 머신(stack-based interpreted machine)
	- while loop 안의 switch 문 으로 기본적 이해 충분, 내부 구조 훨씬 복잡

- java HelloWorld.java 파일을 실행하면 , 자바 바이너리를 시작 이과정에서 자바 가상환경이 설정되고, HelloWorld.class 파일을 실제로 실행할 인터프리터로 초기화 된다.
- HelloWorld.class 의 main() 메서드는 진입점 이며 프로그램 시작 전에 자바 가상 머신이 해당 클래스를 로드해야 합니다.

- **Bootstrap Class Loader:** 자바 프로세스가 시작될 때 가장 먼저 작동하는 로더입니다. `java.lang.Object`나 `Class` 같은 핵심적인 클래스들을 메모리에 올리는 역할을 합니다
- **클래스 로딩의 연쇄 작용:** Bootstrap Class Loader가 핵심 클래스를 로드하면, 이어서 다른 클래스 로더들이 차례로 애플리케이션의 나머지 클래스들을 로드하게 됩니다. 이는 마치 협업을 통해 시스템을 부팅하는 것과 같습니다. 이 과정이 효율적으로 이루어져야 애플리케이션의 시작 속도가 빨라지고, 메모리 사용량도 최적화될 수 있습니다.

- JPMS(Java Platform Module System)의 영향
	- **놀리식 JVM의 종말:** 자바 9 이후 모든 JVM은 모듈형으로 동작합니다. 이는 기존의 거대한 하나의 런타임 환경에서 벗어나, 필요한 모듈만 포함하여 런타임을 구성할 수 있게 되었다는 의미입니다.
	- **경량화 및 의존성 관리:** JPMS는 애플리케이션이 필요로 하는 자바 런타임 모듈만 선택적으로 포함할 수 있게 함으로써, 전체 런타임의 크기를 획기적으로 줄일 수 있습니다. 이는 특히 컨테이너 환경에서 매우 유리합니다. 더 작아진 이미지 크기는 배포 속도를 향상시키고, 리소스 사용량을 절감하는 효과를 가져옵니다. 또한, 명시적인 모듈 의존성 관리를 통해 런타임 시 불필요한 클래스가 로드되는 것을 방지하고, 클래스 패스 충돌(jar hell) 문제를 완화할 수 있습니다.

- 모듈 그래프(Module Graph)의 중요성
	JPMS의 핵심은 **모듈 그래프**를 구성하는 것입니다. 이는 애플리케이션의 모듈 의존 관계를 표현하는 방향성 비순환 그래프(DAG, Directed Acyclic Graph)입니다.
	- **치명적인 시작 오류 방지:** 모듈 간에 순환 참조(cycle)가 발생하면 애플리케이션 시작 시점에서 즉시 오류가 발생합니다. 이는 코드의 순환 의존성을 사전에 차단함으로써, 런타임에 발생할 수 있는 복잡한 오류나 예측 불가능한 동작을 예방하는 중요한 장치입니다. 개발 초기 단계에서부터 아키텍처의 건전성을 강제하여 **유지보수성과 안정성을 크게 향상**시킵니다. 
	  cc. 자바 9 부터 순환 참조를 방지 할 수 있었구나.. 애플리케이션 시작 시점에서 또는 컴파일 시점에서 오류 발생시켜준다.
	- 효율적인 리소스 로딩 : 필요로 하는 모듈만 정확하게 식별하고 로드. 애플리케이션의 시작 시간은 단축하고 메모리 사용량을 최적화 했다.

- 클래스 로더의 역할 변화
	- **부트스트랩 클래스 로더(Bootstrap Class Loader):** 이 로더는 `java.base`와 같이 극도로 필수적인 모듈만을 로드합니다. 이전 버전(자바 8)에서 `rt.jar` 전체를 로드했던 것과 달리, 로딩 범위가 최소한으로 제한되었습니다. 이는 초기 부팅 과정을 최대한 가볍고 빠르게 만드는 데 목적이 있습니다.


- 애플리케이션 클래스 로더의 역할
	- **사용자 정의 클래스 로딩:** 애플리케이션 클래스 로더는 우리가 개발한 **사용자 정의 클래스**를 `classpath`에서 찾아 로드하는 역할을 합니다. 이름에서 알 수 있듯이, 이는 애플리케이션의 핵심적인 부분을 메모리에 올리는 주체입니다. 이 로더는 플랫폼 클래스 로더를 부모로 삼아, 필요한 경우 상위 로더에게 클래스 로딩을 위임합니다.
	- **"System" 클래스 로더라는 용어의 문제:** 텍스트는 이 로더를 '시스템 클래스 로더'라고 부르지 않아야 한다고 강조합니다. 이는 혼란을 야기할 수 있기 때문입니다. 시스템 클래스(핵심 JDK 클래스)는 이미 부트스트랩 또는 플랫폼 클래스 로더에 의해 로드되었으므로, 이 용어의 오용을 피하는 것이 명확한 의사소통에 중요합니다.

- 클래스 로딩의 핵심 원칙과 시사점
	1. **지연 로딩(Lazy Loading):** 자바는 새로운 클래스를 코드 실행 중 처음 만났을 때 로드합니다. 이는 애플리케이션의 시작 시간을 단축하고, 필요하지 않은 클래스를 미리 메모리에 올리지 않아 **리소스 효율성을 극대화**하는 매우 중요한 메커니즘입니다. 
		1. cc. 이전에는 전부 다 로딩하고 시작이였나.? orm 에서 지연로딩과 다르게 .class 파일 읽어들이는 시점을 미루는것.
	2. **부모-자식 위임 모델(Parent-Delegation Model):** 클래스 로더는 클래스를 찾지 못하면 부모 로더에게 로딩을 위임하는 방식으로 동작합니다. 이 위임 체인은 애플리케이션 로더 → 플랫폼 로더 → 부트스트랩 로더 순으로 이어집니다. 이 모델 덕분에 표준 JDK 클래스(부모 로더가 로드)가 사용자 클래스(자식 로더가 로드)에 의해 덮어쓰여지는 보안 및 안정성 문제를 방지할 수 있습니다.
	3. **컴파일과 런타임 환경의 일치:** 텍스트는 컴파일에 사용된 `classpath`와 운영 환경의 `classpath`를 동일하게 유지하는 것의 중요성을 강조합니다. 만약 두 환경의 클래스패스가 다르다면, 개발 환경에서는 문제없던 클래스가 운영 환경에서 `ClassNotFoundException`을 일으킬 수 있습니다. 이는 빌드 및 배포 파이프라인에서 **환경 일관성**을 철저히 관리해야 함을 시사합니다


- 클래스 로더의 다중성(Multiple Class Loaders)
	- **클래스의 유일성:** 보통 자바는 클래스를 한 번만 로드하지만, 텍스트는 같은 이름의 클래스가 다른 클래스 로더에 의해 두 번 로드될 수 있다고 설명합니다. 이 경우, `클래스명`과 함께 **해당 클래스를 로드한 `클래스 로더`**가 클래스의 고유한 식별자가 됩니다.
	- **실제 사례:** 이 동작은 특히 **애플리케이션 서버**에서 유용하게 활용됩니다. 예를 들어, 톰캣(Tomcat)과 같은 서버는 각 애플리케이션(테넌트)마다 고유한 클래스 로더를 할당하여, 동일한 서버 내에서 여러 애플리케이션이 서로 다른 버전의 라이브러리를 사용하도록 허용합니다. 이는 **다중 테넌트 환경의 독립성**을 보장하는 핵심 기술입니다. 
	  cc. 현대 적인 구조에서는 하나의 톰캣 하나의 애플리케이션만 배포하는게 일반적임.
