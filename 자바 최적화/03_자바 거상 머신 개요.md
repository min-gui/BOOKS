


```table-of-contents
```



전세계 1,000 만 명 이상의 개발자가 사용하는걸로 추정.
고수준의 설계를 바당으로 개발자의 부담을 줄이는 것을 목표.
6장 읽은후 다시 돌와서 읽기.


### 3.1 인터프리팅과 클래스 로딩
---

- 자바 가상 머신 : 스택 기반 인터프리터 머신(stack-based interpreted machine)
	- while loop 안의 switch 문 으로 기본적 이해 충분, 내부 구조 훨씬 복잡

- java HelloWorld 파일을 실행하면 , 자바 바이너리를 시작 이과정에서 자바 가상환경이 설정되고, HelloWorld.class 파일을 실제로 실행할 인터프리터로 초기화 된다.
- HelloWorld.class 의 main() 메서드는 진입점 이며 프로그램 시작 전에 자바 가상 머신이 해당 클래스를 로드해야 합니다.

- **Bootstrap Class Loader:** 자바 프로세스가 시작될 때 가장 먼저 작동하는 로더입니다. `java.lang.Object`나 `Class` 같은 핵심적인 클래스들을 메모리에 올리는 역할을 합니다
- **클래스 로딩의 연쇄 작용:** Bootstrap Class Loader가 핵심 클래스를 로드하면, 이어서 다른 클래스 로더들이 차례로 애플리케이션의 나머지 클래스들을 로드하게 됩니다. 이는 마치 협업을 통해 시스템을 부팅하는 것과 같습니다. 이 과정이 효율적으로 이루어져야 애플리케이션의 시작 속도가 빨라지고, 메모리 사용량도 최적화될 수 있습니다.

- JPMS(Java Platform Module System)의 영향
	- **놀리식 JVM의 종말:** 자바 9 이후 모든 JVM은 모듈형으로 동작합니다. 이는 기존의 거대한 하나의 런타임 환경에서 벗어나, 필요한 모듈만 포함하여 런타임을 구성할 수 있게 되었다는 의미입니다.
	- **경량화 및 의존성 관리:** JPMS는 애플리케이션이 필요로 하는 자바 런타임 모듈만 선택적으로 포함할 수 있게 함으로써, 전체 런타임의 크기를 획기적으로 줄일 수 있습니다. 이는 특히 컨테이너 환경에서 매우 유리합니다. 더 작아진 이미지 크기는 배포 속도를 향상시키고, 리소스 사용량을 절감하는 효과를 가져옵니다. 또한, 명시적인 모듈 의존성 관리를 통해 런타임 시 불필요한 클래스가 로드되는 것을 방지하고, 클래스 패스 충돌(jar hell) 문제를 완화할 수 있습니다.

- 모듈 그래프(Module Graph)의 중요성
	JPMS의 핵심은 **모듈 그래프**를 구성하는 것입니다. 이는 애플리케이션의 모듈 의존 관계를 표현하는 방향성 비순환 그래프(DAG, Directed Acyclic Graph)입니다.
	- **치명적인 시작 오류 방지:** 모듈 간에 순환 참조(cycle)가 발생하면 애플리케이션 시작 시점에서 즉시 오류가 발생합니다. 이는 코드의 순환 의존성을 사전에 차단함으로써, 런타임에 발생할 수 있는 복잡한 오류나 예측 불가능한 동작을 예방하는 중요한 장치입니다. 개발 초기 단계에서부터 아키텍처의 건전성을 강제하여 **유지보수성과 안정성을 크게 향상**시킵니다. 
	  cc. 자바 9 부터 순환 참조를 방지 할 수 있었구나.. 애플리케이션 시작 시점에서 또는 컴파일 시점에서 오류 발생시켜준다.
	- 효율적인 리소스 로딩 : 필요로 하는 모듈만 정확하게 식별하고 로드. 애플리케이션의 시작 시간은 단축하고 메모리 사용량을 최적화 했다.

- 클래스 로더의 역할 변화
	- **부트스트랩 클래스 로더(Bootstrap Class Loader):** 이 로더는 `java.base`와 같이 극도로 필수적인 모듈만을 로드합니다. 이전 버전(자바 8)에서 `rt.jar` 전체를 로드했던 것과 달리, 로딩 범위가 최소한으로 제한되었습니다. 이는 초기 부팅 과정을 최대한 가볍고 빠르게 만드는 데 목적이 있습니다.


- 애플리케이션 클래스 로더의 역할
	- **사용자 정의 클래스 로딩:** 애플리케이션 클래스 로더는 우리가 개발한 **사용자 정의 클래스**를 `classpath`에서 찾아 로드하는 역할을 합니다. 이름에서 알 수 있듯이, 이는 애플리케이션의 핵심적인 부분을 메모리에 올리는 주체입니다. 이 로더는 플랫폼 클래스 로더를 부모로 삼아, 필요한 경우 상위 로더에게 클래스 로딩을 위임합니다.
	- **"System" 클래스 로더라는 용어의 문제:** 텍스트는 이 로더를 '시스템 클래스 로더'라고 부르지 않아야 한다고 강조합니다. 이는 혼란을 야기할 수 있기 때문입니다. 시스템 클래스(핵심 JDK 클래스)는 이미 부트스트랩 또는 플랫폼 클래스 로더에 의해 로드되었으므로, 이 용어의 오용을 피하는 것이 명확한 의사소통에 중요합니다.

- 클래스 로딩의 핵심 원칙과 시사점
	1. **지연 로딩(Lazy Loading):** 자바는 새로운 클래스를 코드 실행 중 처음 만났을 때 로드합니다. 이는 애플리케이션의 시작 시간을 단축하고, 필요하지 않은 클래스를 미리 메모리에 올리지 않아 **리소스 효율성을 극대화**하는 매우 중요한 메커니즘입니다. 
		1. cc. 이전에는 전부 다 로딩하고 시작이였나.? orm 에서 지연로딩과 다르게 .class 파일 읽어들이는 시점을 미루는것.
	2. **부모-자식 위임 모델(Parent-Delegation Model):** 클래스 로더는 클래스를 찾지 못하면 부모 로더에게 로딩을 위임하는 방식으로 동작합니다. 이 위임 체인은 애플리케이션 로더 → 플랫폼 로더 → 부트스트랩 로더 순으로 이어집니다. 이 모델 덕분에 표준 JDK 클래스(부모 로더가 로드)가 사용자 클래스(자식 로더가 로드)에 의해 덮어쓰여지는 보안 및 안정성 문제를 방지할 수 있습니다.
	3. **컴파일과 런타임 환경의 일치:** 텍스트는 컴파일에 사용된 `classpath`와 운영 환경의 `classpath`를 동일하게 유지하는 것의 중요성을 강조합니다. 만약 두 환경의 클래스패스가 다르다면, 개발 환경에서는 문제없던 클래스가 운영 환경에서 `ClassNotFoundException`을 일으킬 수 있습니다. 이는 빌드 및 배포 파이프라인에서 **환경 일관성**을 철저히 관리해야 함을 시사합니다


- 클래스 로더의 다중성(Multiple Class Loaders)
	- **클래스의 유일성:** 보통 자바는 클래스를 한 번만 로드하지만, 텍스트는 같은 이름의 클래스가 다른 클래스 로더에 의해 두 번 로드될 수 있다고 설명합니다. 이 경우, `클래스명`과 함께 **해당 클래스를 로드한 `클래스 로더`**가 클래스의 고유한 식별자가 됩니다.
	- **실제 사례:** 이 동작은 특히 **애플리케이션 서버**에서 유용하게 활용됩니다. 예를 들어, 톰캣(Tomcat)과 같은 서버는 각 애플리케이션(테넌트)마다 고유한 클래스 로더를 할당하여, 동일한 서버 내에서 여러 애플리케이션이 서로 다른 버전의 라이브러리를 사용하도록 허용합니다. 이는 **다중 테넌트 환경의 독립성**을 보장하는 핵심 기술입니다. 
	  cc. 현대 적인 구조에서는 하나의 톰캣 하나의 애플리케이션만 배포하는게 일반적임.

### 3.2 바이트 코드 실행
---
- javac : 자바 코드를 .class 파일로 변환하여 바이트 코드를 생성하는것. 이때 최적화를 거의 수행 하지 않습니다. 생성된 바이트 코드는 javap과 같은 도구로 확인할경우 여전히 자바 코드와 유사한 형태입니다.
- 가상머진의 강력함은 주로 런타임에서 일어납니다.

- 컴파일된 소프트웨어는 가상 머신이 지원되는 모든 플랫폼에서 실행 가능합니다.


``` mermaid
sequenceDiagram
    participant 자바 소스 코드
    participant .class file
    자바 소스 코드->>.class file: javac

```



- 클래스 파일 구성 요소
	- 매직 넘버 : 0xCAFEBABE(클래스 파일임을 나타내는 고유 식별자)
	- 버전 : 클래스 파일 형식의 마이너 버전 또는 메이저 버전
	- 상수 풀 : 클래스 상수 풀 (문자열 숫자, 메서드, 클래스 등의 참조 포함)
	- 접근 제어 플래그 : 클래스가 추상적, 정적 등인지 나타내는 플러그
	- 현재 클래스 : 현재 클래스의 이름
	- 슈퍼 클래스 : 슈퍼 클래스의 이름
	- 인터페이스 : 클래스가 구현하는 인터페이스 목록
	- 필드 : 클래스에 정의된 필드(멤버 변수) 목록
	- 메서드 : 클래스에 정의된 메서드 목록(바이트코드 포함)
	- 속성 : 클래스의 속성


- 자바 9에서는 모듈파일을 위해 새로운 매직넘버 도입 0xCAFEDADA

### 3.3 핫 스팟 소개
---
가상머신 성능을 C나 C++ 와 비교할 수 있는 수준까지 끌어 올렸습니다.
기계어 코드로 변환하는 작업은 AOT(Ahead of time compilation) 컴파일 이라고 합니다.
저수준 언어들은 위 작업이 있어서 성능 최적화는 되지만 개발, 관리에 시간이 오래걸린다.
자바는 제로-오버헤드(프로그램이 특정 기능을 사용하지 않을 때는 그 기능 때문에 성능 저하나 메모리 사용량 증가 같은 추가적인 비용이 발생하지 않아야 한다) 추상화 철학을  따르지 않는다.
핫스팟 가상머신은 가상머신에 맞추기위해 구조를 왜곡하지 않아도 된다.

### 3.4 JIT 컴파일 소개
---
- 자바는 바이트 인터프리터에서 시작하며, 명령어는 가상화 스택 머신에서 처리됩니다.
  핫스팟은 바이트코드를 네이티브 코드로 컴파일하여 성능을 향상시킵니다. 컴파일 단위는 메서드와 루프입니다.
- 실행 빈도가 높은 코드 부분을 관찰하며 작동, 특정 메서드의 실행 빈도가 일정 임계값을 초과하면, 프로파일러가 해당 코드를 컴파일하고 최적화합니다.
  자바코드가 바이트코드, JIT 컴파일을 거치면서 실제로 실행되는 코드는 원래 작성된 소스코드와 매우 다르게 변합니다.
- 전체 마이크로벤치마크을 분석하는 것은 전체 애플리케이션을 분석하는것보다 어렵다.


### 3.5 자바 가상 머신 메모리 관리
---
- 개발자가 언어 기능을 처리하는 데 많은 시간을 들이다 보니, 정작 비즈니스 가치를 창출하는 데 집중하지 못할 위험이 있다. 가비지 컬렉션을 통행 자동으로 관리되는 힙 메모리 도입.
- 가비지 컬렉션이 실행되면 stopped the world 발생. 그럼에도 불고하고 기본 알고리즘보다 훨씬 정교하고 멈춤 시간을 최소화

### 3.6 스레딩 과 자바 메모리 모델
---
자바는 멀티스레드 프로그래밍을 기본적으로 지원하는것.
- 자바의 스레드와 운영 체제의 플랫폼 스레드는 과거에 차이가 있었습니다. 스레드 풀에 매핑, 다중화 되었다.불필요한 복잡성 초래. 그결과 슬드가 하나의 플랫폼 스레드에 정확히 대응하는 방식으로 변경.

- 가상스레드 : 자바 21이상에서 사용할 수 있는 새로운 스레드 형태, 네트워크 I/O와 같은 많은 동시 실행 컨텍스트를 필요로 하는 작업에서 강력한 성능 발휘.

- 멀티스레드 기본 설계 원칙
	- 자바 프로세스의 모든 스레드는 하나의 공통적인 가비지 컬렉션 힙을 공유합니다.
	- 하나의 스레드에서 생성된 객체는 해당 객체에 대한 참조를 가진 다른 스레드에서 접근 불가.
	- 객체 필드에 저장된 값은 프로그래머가 명시적으로 final 키워드를 사용해 불변임을 표시하지 않는 한 변경될 수 있습니다.

- 객체 손실 방지위한 상호 배제 잠금 제공 . 13장에서 더자세히
  cc. 어떻게 방지 한다는 거지 각자 생성하고 주도권을 각자 가지는 건가 ?
### 3.7 자바 가상 머신 모니터링 또는 도구
---
- 자바 관리 확장 프로그램(java management extensions(JMX))
	- (Remote Method Invocation)RMI은 자바 가상 머신 관리 기능의 근본적인 요소입니다. 
- 자바 에이전트
	- META-INF/MANIFEST.MF 라는 매니페스트 파일이 포함되어야 하며, 이파일에는 Premain-Class 속성이 반드시 포함 되어야 합니다.
- 자바 가상 머신 도구 인터페이스 JVM tool interface(JVMTI)
- 서비스 지원 에이전트 serviceability agent(SA)
	- 자바 프로세스뿐만 아니라 코어 파일 도 디버깅할 수 있는 기능을 제공합니다.


### 3.8 자바 구현, 배포 또는 릴리스
---
오라클 JDK 만 익숙할 수 있다. 여러가지 다른 JDK 도 많다.
자바 구현을 빌드하는데 필요한 소스 코드는 두 부분으로 나뉩니다.
- 가상 머신 소스 코드
- 클래스 라이브러리 소스 코드

