


```table-of-contents
```


### 개요
---
- Mark and Sweep(추적 가비지 컬랙션) 기본 개요부터 시작.
- 핫스팟 런타임의 저수준 기능과 런타임에서 자바 객체를 어떻게 표현하는지 살펴봅니다.
- 병렬 컬렉터를 소개 몇가지 세부사항을 설명.
- 시스템 내의 모든 객체의 정확한 수명 주기를 이해해야 한다.

초창기에 가비지 컬랙션은 성능이 좋지 않았다. 그러나 현재는 대부분 프로덕션에 적합하고 매우 빠릅니다.
메모리를 수동으로 관리 해야한다는 개발자는 대부분 사라졌고, 러스트 고 같은 프로그래밍 언어조차 메모리 관리를 컴파일러와 런타임의 적절한 역할로 간주 합니다.
가비지 컬렉션은 2기본 규칙을 준수 합니다.
- 활성 객체는 절대 수집되지 않아야 합니다. (더 중요)
	- 일부 가비지를 지속적으로 수집못해 애플리케이션이 메모리 모두 소진하는 문제는 활성객체 잘못 수집하여 메모리 손상을 유발하는 것보다 상대적으로 나은 상황입니다.
- 알고리즘은 모든 가비지를 수집해야 합니다.
	- 종종 오래된 객체를 힙에 오랫동안 남겨둔다. 메모리 영역에 가비지가 충분히 쌓이지 않았다면 해당 영역을 수집하지 않는 방식도 있습니다.


### 4.1 Mark and Sweep(마크 앤 스윕 소개)
---
이 알고리즘에 기반하여 실행 되고 있지만, 어떻게 실제 작동하는지 잘 또올리지 못합니다.

아직 회수되지 않은 할당된 객체 각각에 대한 포인터를 보관하기 위해 ‘할당된 객체 리스트(allocated object list)’를 사용한다. 
1. 할당된 리스트를 순회하며 마크 비트를 초기화.
2. 힙으로의 모든 포인터를 시작점으로 하여 접근 가능한 모든 객체를 찾습니다.
3. 도달한 각 객체에 마크 비트를 설정.
4. 할당된 리스트를 수회, 마크 비트가 설정되지 않은 객체에 대해 다음 작업을 수행.
	- 힙에서 해당 객체의 메모리를 회수하여 자유 리스트에 다시 추가.
	- 객체를 할당된 리스트에서 제거.
	- 활성 객체는 보통 깊이 우선 탐색 DFS로 탐색, 이렇게 만들어진 그래프를 활성 객체 그래프 라고합니다.
	  이는 접근 가능한 객체의 추이적 폐쇄 라고도 부른다.

jmap -histo : 힙의 상태를 시각화 해주는 명령줄 도구 힙의 스냅샷을 보여줍니다.
실시간 분석이 필요할 때 VisualGC 플러그인 샘플링 탭 같은 GUI 도구를 활용 할 수 있다.

### 4.2 가비지 컬렉션 용어집
---
- STW(Stop-The-World)
	- 가비지 컬렉션 사이클이 진행되는 동안 모든 애플리케이션 스레드를 멈춰야 합니다.
	  애플리케이션 코드가 가비지 컬렉현 스레드가 보는 힙 상태를 무효화하지 않도록 방지하는 역할을 합니다.
- 동시성
	- 가비지 컬렉션 스레드가 애플리케이션 스레드가 실행되는 동안에도 동작할 수 있습니다.
	  구현 더 어렵고 ,계산 자원을 더 많이 소모. 자바 9부터 핫스팟의 기본 가비지 컬렉터는 G1 이며, G1dms 일부 동시성 측면을 가지고 있다.
- 병렬
	- 가비지 컬렉션 작업을 여러 스레드와 여러 코어를 사용해 실행
- 정확성
	- 힙 상태에 대한 정보를 충분히 가지고 있어, 단일 사이클에서 모든 가비지를 수집할 수 있습니다. 정확한 방식에서는 Int 필드와 객체 참조 필드를 항상 구별할 수 있습니다.
- 보수성
	- 정확한 방식과 달리 타입 정보를 충분히 제공하지 않습니다. 그결과 자원 낭비가 있고, 표현하려는 타입 시스템을 완벽히 이해하지 못해 효율서이 낮습니다.
- 이동
	- 객체가 메모리 내에서 재배치될 수 있습니다. 객체가 고정된인 주소를 갖지 않음을 의미. 자바와 달리 원시 포인터(raw pointer)에 직접 접근을 제공하는 환경은 이동형 가비지 컬렉터와 자연스럽게 잘 맞지 않습니다.
- 압축
	- 가비지 컬렉션 사이클이 끝날 때, 할당된 메모리는 단일 연속 영역에 배치되고, 새로운 객체를 기록할 수 있는 빈 공간의 시작 지점을 가리키는 포인터가 존재. 압축 컬렉터는 메모리 단편활르 방지합니다.
- 대피
	- 가비지 컬렉션 사이클이 끝날 때, 수집된 영역은 완전히 비워지고, 모든 활성 객체가 다른 메모리 영역으로 이동(대피)됩니다. 우수한 대피형 컬렉터는 메모리 단편화를 방지합니다.

사용 중인 컬렉터에 따라 컬렉션 작업 중 일부 또는 전부가 애플리케이션 스레드와 동시적으로 수행될 수 있습니다.

### 4.4 핫스팟 런타임 소개
---
핫스팟의 세부적인 디테일 구현을 이해해야한다.
앞으로 올 내용을 대비해 . 자바의 2가지 종류 개념을 기억하는것이 도움 된다.
- Primitive Type(원시 타입, byte, int etc..)
- Object References(객체 타입)

자바에서는 C++ 과 달리 일반적인 주소 역 참조 매커니즘이 없으며, 객체참조를 대상으로 필드에 접근하고, 메소드를 불러오기 위해 오직 오프셋 오퍼레이터를 사용한다. 

자바의 메소드 호출 의미는 Call By Value, 객체 참조의 경우에는 Heap 에서 객체의 주소에서 복사된 값이라는 의미이다.

#### 4.4.1 런타임에 객체 표현
---
핫스팟은 OOP 라고 불리는 구조체를 통해 자바를 표현합니다.
OOP 는 Ordinary Object Pointer 이며, C언어의 의미에서 진짜 포인터 입니다.
이 포인터 들은 참조 타임 로컬 변수의 배치 되어 질 수 있으며, 그곳에서 자바의 스택 프레임으로부터 힙메모리 영역 까지 가리킵니다.

중요하게 기억해야할 한가지는, 핫스팟은 자바 힙을 관리하기위한 시스템 콜은 사용하지 않습니다.
핫스팟은 힙 크기를 Sapce User Code 에서 관리 합니다. 따라서 우리는 GC 서브 시스템이 특정 타임의 성능 문제를 유발하는지 여부를 간단한 관찰 지표를 사용을 확인 할 수 있습니다.

cc. hotspot 은 space user code 에서 자바 힙을 관리하기 때문에 사용자는 간단한 지표로 GC성능 문제를 확인 할 수 있다라는 뜻.