


```table-of-contents
```


### 개요
---
- Mark and Sweep(추적 가비지 컬랙션) 기본 개요부터 시작.
- 핫스팟 런타임의 저수준 기능과 런타임에서 자바 객체를 어떻게 표현하는지 살펴봅니다.
- 병렬 컬렉터를 소개 몇가지 세부사항을 설명.
- 시스템 내의 모든 객체의 정확한 수명 주기를 이해해야 한다.

초창기에 가비지 컬랙션은 성능이 좋지 않았다. 그러나 현재는 대부분 프로덕션에 적합하고 매우 빠릅니다.
메모리를 수동으로 관리 해야한다는 개발자는 대부분 사라졌고, 러스트 고 같은 프로그래밍 언어조차 메모리 관리를 컴파일러와 런타임의 적절한 역할로 간주 합니다.
가비지 컬렉션은 2기본 규칙을 준수 합니다.
- 활성 객체는 절대 수집되지 않아야 합니다. (더 중요)
	- 일부 가비지를 지속적으로 수집못해 애플리케이션이 메모리 모두 소진하는 문제는 활성객체 잘못 수집하여 메모리 손상을 유발하는 것보다 상대적으로 나은 상황입니다.
- 알고리즘은 모든 가비지를 수집해야 합니다.
	- 종종 오래된 객체를 힙에 오랫동안 남겨둔다. 메모리 영역에 가비지가 충분히 쌓이지 않았다면 해당 영역을 수집하지 않는 방식도 있습니다.


### 4.1 Mark and Sweep(마크 앤 스윕 소개)
---
이 알고리즘에 기반하여 실행 되고 있지만, 어떻게 실제 작동하는지 잘 또올리지 못합니다.

아직 회수되지 않은 할당된 객체 각각에 대한 포인터를 보관하기 위해 ‘할당된 객체 리스트(allocated object list)’를 사용한다. 
1. 할당된 리스트를 순회하며 마크 비트를 초기화.
2. 힙으로의 모든 포인터를 시작점으로 하여 접근 가능한 모든 객체를 찾습니다.
3. 도달한 각 객체에 마크 비트를 설정.
4. 할당된 리스트를 수회, 마크 비트가 설정되지 않은 객체에 대해 다음 작업을 수행.
	- 힙에서 해당 객체의 메모리를 회수하여 자유 리스트에 다시 추가.
	- 객체를 할당된 리스트에서 제거.
	- 활성 객체는 보통 깊이 우선 탐색 DFS로 탐색, 이렇게 만들어진 그래프를 활성 객체 그래프 라고합니다.
	  이는 접근 가능한 객체의 추이적 폐쇄 라고도 부른다.

jmap -histo : 힙의 상태를 시각화 해주는 명령줄 도구 힙의 스냅샷을 보여줍니다.
실시간 분석이 필요할 때 VisualGC 플러그인 샘플링 탭 같은 GUI 도구를 활용 할 수 있다.

### 4.2 가비지 컬렉션 용어집
---
- STW(Stop-The-World)
	- 가비지 컬렉션 사이클이 진행되는 동안 모든 애플리케이션 스레드를 멈춰야 합니다.
	  애플리케이션 코드가 가비지 컬렉현 스레드가 보는 힙 상태를 무효화하지 않도록 방지하는 역할을 합니다.
- 동시성
	- 가비지 컬렉션 스레드가 애플리케이션 스레드가 실행되는 동안에도 동작할 수 있습니다.
	  구현 더 어렵고 ,계산 자원을 더 많이 소모. 자바 9부터 핫스팟의 기본 가비지 컬렉터는 G1 이며, G1dms 일부 동시성 측면을 가지고 있다.
- 병렬
	- 가비지 컬렉션 작업을 여러 스레드와 여러 코어를 사용해 실행
- 정확성
	- 힙 상태에 대한 정보를 충분히 가지고 있어, 단일 사이클에서 모든 가비지를 수집할 수 있습니다. 정확한 방식에서는 Int 필드와 객체 참조 필드를 항상 구별할 수 있습니다.
- 보수성
	- 정확한 방식과 달리 타입 정보를 충분히 제공하지 않습니다. 그결과 자원 낭비가 있고, 표현하려는 타입 시스템을 완벽히 이해하지 못해 효율서이 낮습니다.
- 이동
	- 객체가 메모리 내에서 재배치될 수 있습니다. 객체가 고정된인 주소를 갖지 않음을 의미. 자바와 달리 원시 포인터(raw pointer)에 직접 접근을 제공하는 환경은 이동형 가비지 컬렉터와 자연스럽게 잘 맞지 않습니다.
- 압축
	- 가비지 컬렉션 사이클이 끝날 때, 할당된 메모리는 단일 연속 영역에 배치되고, 새로운 객체를 기록할 수 있는 빈 공간의 시작 지점을 가리키는 포인터가 존재. 압축 컬렉터는 메모리 단편활르 방지합니다.
- 대피
	- 가비지 컬렉션 사이클이 끝날 때, 수집된 영역은 완전히 비워지고, 모든 활성 객체가 다른 메모리 영역으로 이동(대피)됩니다. 우수한 대피형 컬렉터는 메모리 단편화를 방지합니다.

사용 중인 컬렉터에 따라 컬렉션 작업 중 일부 또는 전부가 애플리케이션 스레드와 동시적으로 수행될 수 있습니다.

### 4.3 핫스팟 런타임 소개
---
핫스팟의 세부적인 디테일 구현을 이해해야한다.
앞으로 올 내용을 대비해 . 자바의 2가지 종류 개념을 기억하는것이 도움 된다.
- Primitive Type(원시 타입, byte, int etc..)
- Object References(객체 타입)

자바에서는 C++ 과 달리 일반적인 주소 역 참조 매커니즘이 없으며, 객체참조를 대상으로 필드에 접근하고, 메소드를 불러오기 위해 오직 오프셋 오퍼레이터를 사용한다. 

자바의 메소드 호출 의미는 Call By Value, 객체 참조의 경우에는 Heap 에서 객체의 주소에서 복사된 값이라는 의미이다.

#### 4.3.1 런타임에 객체 표현
---
핫스팟은 OOP 라고 불리는 구조체를 통해 자바를 표현합니다.
OOP 는 Ordinary Object Pointer 이며, C언어의 의미에서 진짜 포인터 입니다.
이 포인터 들은 참조 타임 로컬 변수의 배치 되어 질 수 있으며, 그곳에서 자바의 스택 프레임으로부터 힙메모리 영역 까지 가리킵니다.

중요하게 기억해야할 한가지는, 핫스팟은 자바 힙을 관리하기위한 시스템 콜은 사용하지 않습니다.
핫스팟은 힙 크기를 Sapce User Code 에서 관리 합니다. 따라서 우리는 GC 서브 시스템이 특정 타임의 성능 문제를 유발하는지 여부를 간단한 관찰 지표를 사용을 확인 할 수 있습니다.

cc. hotspot 은 space user code 에서 자바 힙을 관리하기 때문에 사용자는 간단한 지표로 GC성능 문제를 확인 할 수 있다라는 뜻.

oops 계열을 구성하는 여러 가지 데이터 구조가 있으며, Java 클래스 인스턴스를 나타내는 종류는 **instanceOops**라고 하고, 배열을 나타내는 경우에는 **arrayOops**라고 한다. 공통 규칙은 자바 힙에 있는 모든 데이터는 반드시 객체해더를 포함해야 합니다.

instanceOop의 메모리 레이아웃은 모든 객체의 존재하는 두 개의 머신 워드로 시작( arrayOop는 여기에 32비트 헤더를 가집니다), 첫번째는 객체 인스턴스별 메타데이터, 두번째는 klass 워드로, 클래스 전체의 메타데이터를 가르키는 포인터 입니다.

klass 워드는 klass 메타데이터를 찾는 데 사용됩니다.``
klass 의 시작 문자 k는 가상 머신 수준의 klass 와 자바의 class<> 객체를 나타내는 instanceOop를 구분하가 위해 사용.

klass는 클래스에 대한 가상함수 테이블(vtable)을 포함하고 있으며, 반면에 `Class<?>` 객체는 리플렉션 호출에 사용되는 메서드 객체 배열을 포함합니다.

Oop는 머신 워드 크기를 따르고 머신에 따라 32비트, 64비트 위에서 돌아가지만 상당한 메모리 낭비 가능성이 있습니다. 이를 완화하기 위해 핫스팟은 압축 oop 기능을 제공합니다.

- 옵션
	- `-XX:UseCompressedOops`
힙 내의 다음 Oop가 압축됩니다.
- 힙에 있는 모든 객체의 klass 워드
- 참조 타입의 인스턴스 필드
- 객체 배열의 각 요소

핫스팟 객체 해더
- 네이티비 크기의 마크 워드
- Klass 워드(압출될 수 있음)
- 객체가 배열인 경우, 길이를 나타내는 32비트 값
- 정렬 규칙에 따라 필요한 경우 32비트 간격
- 해더 바로 뒤에 객체의 인스턴스 필드

과거 지연에 매우 민감한 애플리케이션은 압축 oop 기능을 비활성화하면 성능이 개선되는 경우가 가끔 있었지만, 힙 크기가 증가하는 대가를 치러야 했고, 보통 힙크기가 10% ~ 50% 증가 했습니다.

cc. 압축기능은 64비트를 32비트를 압축, 비활성 상태에서는 주소 계산 없이 직접 참조하여 지연시간 개선된다 그러나 힙크기 증가로 메모리 사용량 증가 STW 증가. OutOfMemoryError 발생 임계점 하향

이점이 없으므로 안티패턴임. 스위치 만지작거리기 라고 부른다. 자바 버전은 순전히 32비트 아키 텍처를 위해 설계. 

#### 4.3.2 가비지 컬렉션 루트
---
GC 는 메모리 관리를 위해 더이상 사용하지 않는 객체를 찾아가는 과정 입니다. GC 가 어떤 객체를 `사용중` 이라고 판단하는 기준이 가비지 컬렉션 루트 입니다.

메모리의 앵커 포인트(anchor point) : 메모리 풀 외부에서 시작하여 해당 메모리 풀 내부를 가리키는 외부 포인터 의미. 

내부 포인터 : 메모리 풀 내부에서 시작하여 같은 메모리 풀 내의 다른 위치를 가리키는 포인터.

가비지 컬렉션 루트 종류
- 스택 프레임(stack frames)
- JNI (Java Native Interface)
- 레지스터
- 코드루트(자바 가상 머진 코드 캐시에서 유래)
- 글로벌 변수
- 로드된 클래스의 메타 데이터

참조 타임의 로컬 변수가 가비지 컬렉션 루트의 가장 간단한예입니다.
이 이변수는 null이 아닌 한 항상 입에 있는객체를 가리킵니다.
- **`null이 아닌 한`**: 참조 변수(`name`)가 `null` 값을 가지고 있다면, 그것은 **어떤 객체도 참조하고 있지 않다**는 뜻입니다. 이 경우, GC 루트의 역할을 할 수 없습니다.

ex) GC 예제
``` java
public void processData() {
    String message = "Hello, World!"; // message는 지역 변수
    // ... 메서드 로직
}

```

위 코드에서 `message` 변수는 `processData()` 메서드의 스택 프레임 안에 존재합니다. 이 `message` 변수는 `"Hello, World!"`라는 `String` 객체를 참조하고 있습니다.
- **`message` 변수:** GC 루트 중 하나인 **스택 프레임**에 속해 있습니다.
- **`"Hello, World!"` 객체:** `message` 변수에 의해 참조되고 있습니다.

이때 GC는 `message` 변수라는 루트에서 시작하여 `"Hello, World!"` 객체를 발견합니다. 따라서 이 객체는 "사용 중인 객체"로 분류되어 GC의 대상이 되지 않습니다.

하지만 `processData()` 메서드가 종료되면, 스택 프레임이 사라지고 `message` 변수도 함께 사라집니다. 이제 `"Hello, World!"` 객체는 더 이상 어떤 GC 루트에서도 도달할 수 없는 상태가 됩니다. 이 순간, GC는 이 객체를 "가비지"로 인식하고 메모리에서 제거하게 됩니다.


### 4.4 할당과 수명 주기
---
가비지 컬렉터의 주요 요인 2가지
- 할당 속도 : 일정 시간 동안 새로 생성된 객체가 사용하는 메모리양, JFR 같은 도구가 제공 합니다. 
  책 후반부에 다시 다룹니다.
- 객체의 수명 주기 : 보통 측정 하기 매우 어려움, 객체의 수명이 짧기 때문에 동일한 물리적 메모리를 반복적으로 사용할수 있다는 점이 가비지 컬렉션 핵심 기술.

객체의 수명주기와 속도에 따라 트레이드 오프를 균형있게 조정 해야 합니다.

### 4.5 약한 세대 가설
---
소프트웨어 시스템의 런타암에서 관찰되는 약한 세대 가설을 기반합니다.
객체의 수명 분포는 이분분포를 나타냅니다. 대부분의 객체는 수명이 매우 짧은 반면, 일부 객체는 훨 씬 더 긴수명을 가집니다.

주요 기술중 하나는 최근 생성된 객체가 있는 Eden에 Mark And Sweep컬렉션을 사용 하는 것입니다.
스윕 단계에서 evacuation 단계를 통해 생존한 객체를 긴 수명 공간으로 이동 시킵니다.
그런 다음 Eden 공간 전체를 한 번에 회수 합니다.

세대별 힙을 사용하는 주요 이점 중 하나는 죽은 객체를 수집하는데 비용이 전혀 들지 않는다는 점. 관심 대상은 오직 활성 개체뿐이다.

 핫스팟은 약한 세대 가설을 활용 합니다.
cc. 새로 생성된 객체를 우선적으로 탐색한다.

### 4.6 핫스팟의 프로덕션 가비지 컬렉션 기술
---
가비지 컬렉터가 작동하는 방식을 이해하는데 도움이 되는 몇 가지 기술을 소개하겠습니다.

#### 4.6.1 스레드 - 로컬 할당
Eden 은 힙의 영역중 대부분의 객체가 생성되는 영역. 수명이 매우 짧은 객체가 존재 합니다.
이 영역에서 많은 객체를 추가 비용 없이 수집 할 수 있습니다.

할당 효율성을 개선 하기 위해 핫스팍은 Eden을 여러 개의 버퍼로 분할하고 각 애플리케이션 스레드에 독립적인 Eden 영역을 할당하여 새 객체를 생성하도록합니다.
다른스레드가 동일한 버퍼에서 할당 작업을 수행하는것을 걱정할 필요가 없습니다.
이러한 영역을 스레드 로컬 할당 버퍼(TLAB) 라고 합니다.

** 핫스팟은 애플리케이션 스레드에 할당하는 스레드-로컬 할당 버퍼를 동적으로 조정. 특정 스레드가 메모리를 
빨르게 소모하는 경우 해당, 해당 스레드에 더 큰 TLAB을 할당하여 버퍼를 제공한다.

애플리케이션 스레드가 현재 스레드-로컬 할당 버퍼를 모두 채우면, 자바 가상 머신은 에덴의 새로운 영역을 할당하여 , 새로운 스레드-로컬 할당 버퍼에 대한 포인터를 제공합니다.

더이상 할당할 스레드-로컬 할당 버퍼가 없을경우 ,젊은 세대 가비지 컬렉션이  발생한다는 것을 뜻합니다.

#### 4.6.2 반구형 컬렉션
---
hemispheric evacuating collector(반구형 대피 컬렉터) : 보통 같은 크기의 두 개 공간을 사용합니다.
핵심 개념은 한공간을 실제로 오래 지속되지 않는 객체의 임시 보관 장소로 활용하는 것입니다. 이를통해 짧은 수명의 객체가 tenured generation(영구 세대)에 혼입되는것을 방지. 전체 가비지 컬렉션의 빈도를 줄일 수 있습니다.
- 컬렉터가 현재 활성화된 반구를 수집할 때, 객체는 압축 방식으로 다른 반구로 이동되며, 수집된 반구는 재사용을 위해 비워집니다.
- 공간의 절반은 항상 완전히 비워진 상태로 유지됩니다.
핫스팟 젋은 힙의 반구형 영역은 Survivor(서바이버)공간입니다. Eden 영역보다 상대적으로 작으며, 젊은 세대 컬렉션이 진행될 때마다 역할이 교대됩니다.

#### 4.6.3 클래식 핫스팟 힙
---
- 세대 카운트(지금까지 생존한 가비지 컬렉션 수)를 추적
- 큰 개체를 제외 하고 ,새 객체는 Eden 공간 에 생성되며, 생존한 객체는 두 개의 서바이버 공간 중 하나로 이동.
- 메모리 별도 영역(오래되었거나 영구한 세대)을 유지하여, 일정기간 생존한 객체를 저장합니다. 이러한 객체는 오래 지속될 가능성이 높다고 간주 됩니다.
- 메모리 세데별 수집을 위해, 외부에서 젊은 세대를 가리키는 포인터를 추적하는 것이빈다. 전체를 순회하지 않고 여전히 살아 있는 젊은 객체를 효율적으로 식별 할 수 있습니다.

위 과정을 지원하기 위해 핫스팟은 카드테이블 이라는 구조를 유지합니다. 카드 테이블은 오래된 세대의 객체가 젊은 객체를 가리킬 가능성을 기록하는 데 사용됩니다. 이는 기본적으로 자바 가상 머신에서 관리되는 바이트 배열로, 배열의 각 요소는 오래된 세대 공간의 512 바이트 여역을 나타냅니다.

** 추후 더 정교한 기억 집합을 다룰 예정입니다.

이기술의 핵심은 오래된 객체 o의 참조 타입 필드가 수정될때, o 가 포함된 카드의 카드 테이블 항목을 더티로 표시하는 것 입니다. 핫스팟은 참조 필드가 업데이트될 때 간단한 쓰기 장벽을 사용하여 이를 처리 합니다.

`cards[*oop >> 9] = 0;` 
카드의 더티 값은 0이며, 9비트를 오른쪽으로 이동하면 카드 테이블의 크기가 512바이트 임을 알 수 있습니다.

이건 오래전 이야기 현대적인 컬렉터인 G1 은세대를 연속적인 저장소로 관리 하지 않습니다. 
대신 인접 하지 않아도 되는 region(영역) 기반 구조를 사용합니다.

5.3 에서 자세히 다룰 예정

### 4.7 병렬 컬렉터
---
- ParNew
	- 병렬 가비지 컬렉션 변형 버전 , 더 이상 사용되지 않는 동시 마크 스윕 컬렉터와 함께 사용
- ParallelOld
	- 영구 세대를 위한 병렬 컬렉터

병렬 컬렉터는 최소한의 기록 관리로 작동하도록 반들어 져 있다.

** 자바 7부터 동시 마크 스윕 컬렉터가 제거, 하나의 병렬 가비지 컬렉션만 존재.

#### 4.7.1 젊은 병렬 컬렉션
스레드-로컬 할당 버퍼에 충분한 공간이 없고, 새로 할당할 수 없을때 발생합니다. 이때 모든 애플리케이션 스레드를 중지할 수 밖에 없습니다. 이때 병렬 마킹스캔을 수행합니다. 
생존한 모든 객체를 서바이버 공간으로 이동 시킵니다. 이건 모든 코어를 활용하여 STW 일시 중지 시간을 줄이는 것을 목표로 합니다.

#### 4.7.2 오래된 병렬 컬렉션(Parallel Old)
자바 8까지 기본, 자바 11에서는 G1
오래된 객체가 소멸하며 남겨진 공간을 회수하기위해 오래된 세대 내메에 객체를 재배치 합니다.
자바 17부터 병렬 가비지 컬렉터가 G1 가비지 컬렉터보다 더 나은 성능을 내는 겨우를 찾기가 거의 어렵다.

#### 4.7.3 직렬 또는 SerialOld
단일 CPU 코어만 사용, 특별한 이유가 없는이상 사용 지양.

#### 4.7.4 병렬 컬렉터의 한계
힙 크기가 계속 커지면 ParallelOld는 일시 중시 사간 문제로 확장성에 한곌르 드러내기 시작합니다.


### 4.8 할당의 역할
---
가비지 컬렉터는 일정한 간격으로 실행 되지 않고 필요에 따라 작동. 할당 속도가 높아질수록 가비지 컬렉션은 더 자주 발생하며, 할당 속도가 지나치게 높을 경우 객체가 조기에 승격되는 상황이 발생합니다.

조기 승격은 , 많은 튜닝 작업의 시작점이 됩니다.
### 4.9 요약
---
- 마크 앤 스윕 컬렉션
- 핫스팟의 객체에 대한 내부 런타임 표현 방식
- 약한 세대 가설
- 핫스팟 메모리 서브시스템의 실무적 측면
- 병렬 또는 직렬 컬렉터
- 할당과 그것이 가지는 핵심적인 역할

지금까지 과거 GC 컬렉터를 다룸. 다음장에서 현대적인 컬렉터 동시 컬렉터, G1, 셰넌도어와 ZGC 와 같은 덜 일반적인 대안이 포함.



